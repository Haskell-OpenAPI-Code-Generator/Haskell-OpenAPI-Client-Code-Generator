{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE UndecidableInstances #-}

-- |
-- Module      : OpenAPI.Common
--
-- This module serves the purpose of defining common functionality which stays the same for
-- all OpenAPI definitions
module OpenAPI.Common
  ( Configuration (..),
    doCallWithConfiguration,
    doCallWithConfigurationM,
    doBodyCallWithConfiguration,
    doBodyCallWithConfigurationM,
    runWithConfiguration,
    MonadHTTP (..),
    stringifyModel,
    StringifyModel,
    SecurityScheme (..),
    AnonymousSecurityScheme (..),
    textToByte,
    JsonByteString (..),
    JsonDateTime (..),
    RequestBodyEncoding (..),
  )
where

import qualified Control.Exception as E
import qualified Control.Lens as L
import qualified Control.Lens.TH as LTH
import qualified Control.Monad.Reader as MR
import qualified Control.Monad.Trans.Class as MT
import qualified Data.Aeson as Aeson
import qualified Data.Bifunctor as Bif
import qualified Data.ByteString.Char8 as B8
import qualified Data.Char as Char
import qualified Data.HashMap.Strict as HashMap
import qualified Data.Maybe as M
import qualified Data.Scientific as Scientific
import qualified Data.Text as T
import qualified Data.Time.LocalTime as Time
import qualified Data.Vector as Vector
import qualified GHC.Generics as GHCG
import qualified Network.HTTP.Client as HC
import qualified Network.HTTP.Simple as HS

-- | Abstracts the Usage of 'Network.HTTP.Simple.httpBS' away,
--  so that it can be used for testing
class Monad m => MonadHTTP m where
  httpBS :: HS.Request -> m (Either HS.HttpException (HS.Response B8.ByteString))

-- | This instance is the default instance used for production code
instance MonadHTTP IO where
  httpBS request =
    Bif.first (\e -> e :: HS.HttpException)
      <$> E.try (HS.httpBS request)

instance MonadHTTP m => MonadHTTP (MR.ReaderT r m) where
  httpBS = MT.lift . httpBS

-- | An Operation can and must be configured with data, which may be common
--   for many Operations.
--
--   This configuration consists of Information about the Server and Security
--   Information
--
--   In OpenAPI these information can be defined
--
--     * root level
--
--     * path level
--
--     * Operation level
--
--   For testing purpose a simple DefaultConfiguration can be instantiated.
--   The function 'defaultConfiguration' is generated by the code generator
--
--   @
--     config = defaultConfiguration
--   @
data Configuration s
  = Configuration
      { _baseURL :: T.Text,
        _securityScheme :: s
      }
  deriving (Show, Ord, Eq, GHCG.Generic)

LTH.makeLenses ''Configuration

data RequestBodyEncoding = RequestBodyEncodingJSON | RequestBodyEncodingFormData

-- | Allows to specify an authentication scheme for requests done with 'doCallWithConfiguration'
--
-- This can be used to define custom schemes as well
class SecurityScheme s where
  authenticateRequest :: s -> HS.Request -> HS.Request

-- | The default authentication scheme which does not add any authentication information
data AnonymousSecurityScheme = AnonymousSecurityScheme

-- | Instance for the anonymous scheme which does not alter the request in any way
instance SecurityScheme AnonymousSecurityScheme where
  authenticateRequest = const id

-- | Run the 'MR.ReaderT' monad with a specified configuration
--
-- Note: This is just @flip runReaderT@.
runWithConfiguration :: SecurityScheme s => Configuration s -> MR.ReaderT (Configuration s) m a -> m a
runWithConfiguration = flip MR.runReaderT

-- | This is the main functionality of this module
--
--   It makes a concrete Call to a Server without a body
doCallWithConfiguration ::
  (MonadHTTP m, SecurityScheme s) =>
  -- | Common configuration Options
  Configuration s ->
  -- | HTTP Method (GET,POST,etc.)
  T.Text ->
  -- | The path for which the placeholders have already been replaced
  T.Text ->
  -- | Query Parameters
  [(T.Text, M.Maybe String)] ->
  -- | The Response from the server
  m (Either HS.HttpException (HS.Response B8.ByteString))
doCallWithConfiguration config method path queryParams =
  httpBS $ createBaseRequest config method path queryParams

-- | Same as 'doCallWithConfiguration' but run in a 'MR.ReaderT' environment which contains the configuration.
-- This is useful if multiple calls have to be executed with the same configuration.
doCallWithConfigurationM ::
  (MonadHTTP m, SecurityScheme s) =>
  -- | HTTP Method (GET,POST,etc.)
  T.Text ->
  -- | The path for which the placeholders have already been replaced
  T.Text ->
  -- | Query Parameters
  [(T.Text, M.Maybe String)] ->
  -- | The Response from the server
  MR.ReaderT (Configuration s) m (Either HS.HttpException (HS.Response B8.ByteString))
doCallWithConfigurationM method path queryParams = do
  config <- MR.ask
  MT.lift $ doCallWithConfiguration config method path queryParams

-- | This is the main functionality of this module
--
--   It makes a concrete Call to a Server with a body
doBodyCallWithConfiguration ::
  (MonadHTTP m, SecurityScheme s, Aeson.ToJSON body) =>
  -- | Common configuration Options
  Configuration s ->
  -- | HTTP Method (GET,POST,etc.)
  T.Text ->
  -- | The path for which the placeholders have already been replaced
  T.Text ->
  -- | Query Parameters
  [(T.Text, M.Maybe String)] ->
  -- | body of the request
  body ->
  -- | json or form data deepobjects
  RequestBodyEncoding ->
  -- | The Response from the server
  m (Either HS.HttpException (HS.Response B8.ByteString))
doBodyCallWithConfiguration config method path queryParams body RequestBodyEncodingJSON =
  httpBS $ HS.setRequestBodyJSON body baseRequest
  where
    baseRequest = createBaseRequest config method path queryParams
doBodyCallWithConfiguration config method path queryParams body RequestBodyEncodingFormData =
  httpBS $ HS.setRequestBodyURLEncoded byteStringData baseRequest
  where
    baseRequest = createBaseRequest config method path queryParams
    byteStringData = createFormData baseRequest body

-- | Same as 'doBodyCallWithConfiguration' but run in a 'MR.ReaderT' environment which contains the configuration.
-- This is useful if multiple calls have to be executed with the same configuration.
doBodyCallWithConfigurationM ::
  (MonadHTTP m, SecurityScheme s, Aeson.ToJSON body) =>
  -- | HTTP Method (GET,POST,etc.)
  T.Text ->
  -- | The path for which the placeholders have already been replaced
  T.Text ->
  -- | Query Parameters
  [(T.Text, M.Maybe String)] ->
  -- | body of the request
  body ->
  -- | json or form data deepobjects
  RequestBodyEncoding ->
  -- | The Response from the server
  MR.ReaderT (Configuration s) m (Either HS.HttpException (HS.Response B8.ByteString))
doBodyCallWithConfigurationM method path queryParams body encoding = do
  config <- MR.ask
  MT.lift $ doBodyCallWithConfiguration config method path queryParams body encoding

-- | Creates a Base Request
createBaseRequest ::
  SecurityScheme s =>
  -- | Common configuration Options
  Configuration s ->
  -- | HTTP Method (GET,POST,etc.)
  T.Text ->
  -- | The path for which the placeholders have already been replaced
  T.Text ->
  -- | Query Parameters
  [(T.Text, M.Maybe String)] ->
  -- | The Response from the server
  HS.Request
createBaseRequest config method path queryParams =
  authenticateRequest (config L.^. securityScheme)
    $ HS.setRequestMethod (textToByte method)
    $ HS.setRequestQueryString query
    $ HS.setRequestPath
      (B8.pack (T.unpack $ byteToText (HC.path baseRequest) <> path))
      baseRequest
  where
    baseRequest = parseURL $ config L.^. baseURL
    -- filters all maybe
    query = [(textToByte a, Just $ B8.pack b) | (a, Just b) <- queryParams]

-- | creates form data bytestring array
createFormData :: (Aeson.ToJSON a) => HS.Request -> a -> [(B8.ByteString, B8.ByteString)]
createFormData baseRequest body =
  let formData = jsonToFormData $ Aeson.toJSON body
   in fmap (Bif.bimap textToByte textToByte) formData

byteToText :: B8.ByteString -> T.Text
byteToText = T.pack . B8.unpack

textToByte :: T.Text -> B8.ByteString
textToByte = B8.pack . T.unpack

parseURL :: T.Text -> HS.Request
parseURL baseURL =
  M.fromMaybe HS.defaultRequest
    $ HS.parseRequest
    $ T.unpack baseURL

jsonToFormData :: Aeson.Value -> [(T.Text, T.Text)]
jsonToFormData = jsonToFormDataPrefixed ""

jsonToFormDataPrefixed :: T.Text -> Aeson.Value -> [(T.Text, T.Text)]
jsonToFormDataPrefixed prefix (Aeson.Number a) = case Scientific.toBoundedInteger a :: Maybe Int of
  Just myInt -> [(prefix, T.pack $ show myInt)]
  Nothing -> [(prefix, T.pack $ show a)]
jsonToFormDataPrefixed prefix (Aeson.Bool True) = [(prefix, T.pack "true")]
jsonToFormDataPrefixed prefix (Aeson.Bool False) = [(prefix, T.pack "false")]
jsonToFormDataPrefixed prefix Aeson.Null = []
jsonToFormDataPrefixed prefix (Aeson.String a) = [(prefix, a)]
jsonToFormDataPrefixed "" (Aeson.Object object) =
  HashMap.toList object >>= uncurry jsonToFormDataPrefixed
jsonToFormDataPrefixed prefix (Aeson.Object object) =
  HashMap.toList object >>= (\(x, y) -> jsonToFormDataPrefixed (prefix <> "[" <> x <> "]") y)
jsonToFormDataPrefixed prefix (Aeson.Array vector) =
  Vector.toList vector >>= jsonToFormDataPrefixed (prefix <> "[]")

class Show a => StringifyModel a where
  stringifyModel :: a -> String

instance StringifyModel String where
  -- stringifyModel :: String -> String
  stringifyModel = id

instance {-# OVERLAPS #-} Show a => StringifyModel a where
  -- stringifyModel :: Show a => a -> String
  stringifyModel = show

newtype JsonByteString = JsonByteString B8.ByteString
  deriving (Show, Eq, Ord)

instance Aeson.ToJSON JsonByteString where
  toJSON (JsonByteString s) = Aeson.toJSON $ B8.unpack s

instance Aeson.FromJSON JsonByteString where
  parseJSON (Aeson.String s) = pure $ JsonByteString $ textToByte s

newtype JsonDateTime = JsonDateTime Time.ZonedTime
  deriving (Show)

instance Eq JsonDateTime where
  (JsonDateTime d1) == (JsonDateTime d2) = Time.zonedTimeToUTC d1 == Time.zonedTimeToUTC d2

instance Ord JsonDateTime where
  (JsonDateTime d1) <= (JsonDateTime d2) = Time.zonedTimeToUTC d1 <= Time.zonedTimeToUTC d2

instance Aeson.ToJSON JsonDateTime where
  toJSON (JsonDateTime d) = Aeson.toJSON d

instance Aeson.FromJSON JsonDateTime where
  parseJSON o = JsonDateTime <$> Aeson.parseJSON o
